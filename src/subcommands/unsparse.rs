use std::{fs, path::Path};

use clap::{Arg, ArgMatches, Command};
use lmdb::{Environment, EnvironmentFlags};
use log::{error, info};

pub const COMMAND_NAME: &str = "unsparse";
const DB_PATH: &str = "file-path";

pub fn command(display_order: usize) -> Command<'static> {
    Command::new(COMMAND_NAME)
        .display_order(display_order)
        .about(
            "Reduces the disk size of an LMDB database generated by a Casper node by removing \
            empty blocks of the sparse file.",
        )
        .arg(
            Arg::new(DB_PATH)
                .display_order(0)
                .value_name("DB_PATH")
                .required(true)
                .help("Path to the storage.lmdb file."),
        )
}

pub fn run(matches: &ArgMatches) -> bool {
    let path = Path::new(
        matches
            .value_of(DB_PATH)
            .expect("should have file-path arg"),
    );
    unsparse(path)
}

fn unsparse(path: &Path) -> bool {
    let size_before = match fs::metadata(path) {
        Ok(metadata) => metadata.len(),
        Err(error) => {
            error!("Failed to get metadata for {}: {}", path.display(), error);
            return false;
        }
    };

    let _env = match Environment::new()
        .set_flags(EnvironmentFlags::WRITE_MAP | EnvironmentFlags::NO_SUB_DIR)
        .set_max_dbs(100)
        .set_map_size(1)
        .open(path)
    {
        Ok(env) => env,
        Err(error) => {
            error!("Failed to open {}: {}", path.display(), error);
            return false;
        }
    };

    let size_after = match fs::metadata(path) {
        Ok(metadata) => metadata.len(),
        Err(error) => {
            error!("Failed to get metadata for {}: {}", path.display(), error);
            return false;
        }
    };

    if size_before > size_after {
        info!(
            "Reduced size of {} from {} to {} bytes.",
            path.display(),
            size_before,
            size_after
        );
        true
    } else {
        error!(
            "Failed to reduce size of {} from {} bytes.",
            path.display(),
            size_before
        );
        false
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::LmdbTestFixture;

    #[test]
    fn should_reduce_lmdb_file_size() {
        let fixture = LmdbTestFixture::new(Some("a"));
        let db_path = fixture.tmp_file.path();
        let db_size = || {
            fs::metadata(db_path)
                .unwrap_or_else(|error| {
                    panic!("should get metadata for {}: {}", db_path.display(), error)
                })
                .len()
        };
        let size_before = db_size();
        assert!(unsparse(db_path), "unsparse should succeed");
        let size_after = db_size();
        assert!(size_after < size_before, "unsparse should reduce file size");

        assert!(!unsparse(db_path), "repeat unsparse should fail");
        assert_eq!(db_size(), size_after, "file size should be unchanged");
    }
}
